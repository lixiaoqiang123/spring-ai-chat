# 流式对话记忆功能测试指南

## 问题排查和修复

### 发现的问题

1. **前端 SSE 解析逻辑错误**
   - 原代码无法正确解析 `event:` 和 `data:` 的配对关系
   - 导致无法获取 `done` 事件中的 `sessionId`

2. **Controller 和 Service 层 sessionId 不一致**
   - Controller 获取了 sessionId，但传递给 Service 的是原始 request
   - Service 可能会重新生成不同的 sessionId
   - 导致记忆功能失效

### 修复方案

#### 1. 修复前端 SSE 解析逻辑

**修复前**：
```javascript
// 错误的解析逻辑
if (line.includes('event:')) {
    const eventMatch = buffer.match(/event:\s*(\w+)/);
    // 使用 buffer 而不是当前行，导致匹配错误
}
```

**修复后**：
```javascript
// 正确的解析逻辑
let currentEvent = 'message'; // 默认事件类型

// 先解析事件类型
if (line.startsWith('event:')) {
    currentEvent = line.substring(6).trim();
}
// 再解析数据
else if (line.startsWith('data:')) {
    const data = line.substring(5).trim();

    // 根据事件类型处理数据
    if (currentEvent === 'done') {
        // 获取 sessionId
        const jsonData = JSON.parse(data);
        sessionId = jsonData.sessionId;
    }
}
```

#### 2. 修复 Controller 层 sessionId 传递

**修复前**：
```java
String sessionId = chatService.getOrGenerateSessionId(request);
Flux<String> contentStream = chatService.chatStream(request);
// request 中的 sessionId 可能为 null，Service 会重新生成
```

**修复后**：
```java
String sessionId = chatService.getOrGenerateSessionId(request);
// 创建包含正确 sessionId 的新请求对象
ChatRequest requestWithSession = new ChatRequest(request.message(), sessionId);
Flux<String> contentStream = chatService.chatStream(requestWithSession);
```

#### 3. 添加调试日志

在 Controller 和 Service 层添加日志，便于排查问题：

```java
// Controller
System.out.println("流式对话 - 会话ID: " + sessionId + ", 消息: " + request.message());

// Service
System.out.println("ChatService.chatStream - 使用会话ID: " + sessionId + ", 消息: " + request.message());
System.out.println("流式对话完成 - 会话ID: " + sessionId + ", 消息: " + request.message());
```

## 测试步骤

### 1. 启动应用

```bash
cd E:\AI\spring-api-chat
mvn spring-boot:run
```

### 2. 打开测试页面

在浏览器中访问：
```
http://localhost:8080/stream-test.html
```

### 3. 测试记忆功能

#### 测试场景 1：基本记忆

1. **第一轮对话**
   - 输入：`我的名字叫张三`
   - 观察：页面底部显示会话ID（例如：`会话ID: abc-123`）
   - 查看控制台日志，确认 sessionId

2. **第二轮对话**
   - 输入：`我的名字是什么？`
   - 预期：AI 回复包含"张三"
   - 观察：会话ID 保持不变

3. **第三轮对话**
   - 输入：`我刚才说了什么？`
   - 预期：AI 能够回忆起之前的对话内容

#### 测试场景 2：会话隔离

1. **打开第一个浏览器标签页**
   - 输入：`我喜欢红色`
   - 记录会话ID（例如：`session-1`）

2. **打开第二个浏览器标签页**
   - 输入：`我喜欢蓝色`
   - 记录会话ID（例如：`session-2`）

3. **回到第一个标签页**
   - 输入：`我喜欢什么颜色？`
   - 预期：AI 回复"红色"，而不是"蓝色"

#### 测试场景 3：多轮复杂对话

1. 输入：`我正在学习 Spring AI`
2. 输入：`它有哪些核心功能？`
3. 输入：`我正在学习什么？`
4. 预期：AI 能够记住是 Spring AI

### 4. 查看后端日志

在控制台中查看日志输出：

```
流式对话 - 会话ID: abc-123, 消息: 我的名字叫张三
ChatService.chatStream - 使用会话ID: abc-123, 消息: 我的名字叫张三
流式对话完成 - 会话ID: abc-123, 消息: 我的名字叫张三

流式对话 - 会话ID: abc-123, 消息: 我的名字是什么？
ChatService.chatStream - 使用会话ID: abc-123, 消息: 我的名字是什么？
流式对话完成 - 会话ID: abc-123, 消息: 我的名字是什么？
```

**关键检查点**：
- ✅ 同一会话的多轮对话使用相同的 sessionId
- ✅ 不同标签页使用不同的 sessionId
- ✅ AI 能够记住之前的对话内容

### 5. 查看浏览器控制台

打开浏览器开发者工具（F12），查看 Console 输出：

```
收到事件类型: message
收到事件类型: message
收到事件类型: done
获取到会话ID: abc-123
```

## 常见问题排查

### 问题 1：AI 无法记住对话

**可能原因**：
- sessionId 每次都不同
- 前端没有正确获取和传递 sessionId

**排查方法**：
1. 查看页面底部的会话ID是否保持不变
2. 查看浏览器控制台是否有"获取到会话ID"的日志
3. 查看后端日志，确认每次请求使用相同的 sessionId

### 问题 2：前端无法获取 sessionId

**可能原因**：
- SSE 解析逻辑错误
- 后端没有发送 `done` 事件

**排查方法**：
1. 打开浏览器 Network 标签，查看 SSE 响应内容
2. 确认是否有 `event: done` 和对应的 `data: {"sessionId":"..."}`
3. 查看浏览器控制台是否有解析错误

### 问题 3：不同标签页共享记忆

**可能原因**：
- 前端使用了全局的 sessionId
- sessionId 存储在 localStorage 中

**排查方法**：
1. 确认前端代码中 sessionId 是页面级变量（`let sessionId = null;`）
2. 不要使用 localStorage 存储 sessionId

## 技术细节

### SSE 事件格式

后端发送的 SSE 事件格式：

```
event: message
data: AI 生成的文本片段1

event: message
data: AI 生成的文本片段2

event: done
data: {"sessionId":"abc-123"}
```

### Memory Advisor 工作原理

```java
chatClient.prompt()
    .user(request.message())
    .advisors(advisor -> advisor
        .param(ChatMemory.CONVERSATION_ID, sessionId)  // 传递会话ID
    )
    .stream()
    .content()
```

MessageChatMemoryAdvisor 会：
1. 根据 `CONVERSATION_ID` 从 ChatMemory 检索历史消息
2. 将历史消息添加到当前请求的上下文中
3. 调用 AI 模型生成回复
4. 将当前对话（用户消息和AI回复）存储到 ChatMemory

### 会话隔离机制

- 每个 `sessionId` 对应一个独立的对话历史
- ChatMemory 内部使用 Map 结构存储：`Map<String, List<Message>>`
- 不同 sessionId 的对话历史完全隔离

## 性能优化建议

1. **设置合理的 maxMessages**
   - 当前设置为 20 条消息
   - 可根据实际需求调整

2. **定期清理不活跃会话**
   - 实现会话过期机制
   - 定时清理长时间未使用的会话

3. **使用持久化存储**
   - 生产环境建议使用 Redis 或数据库
   - 避免应用重启导致记忆丢失

## 相关文件

- `ChatController.java:95-140` - 流式对话接口
- `ChatService.java:83-106` - 流式对话服务
- `stream-test.html:256-365` - 前端 SSE 处理逻辑
- `ChatMemoryConfig.java` - Memory 配置

## 总结

通过修复前端 SSE 解析逻辑和后端 sessionId 传递问题，流式对话的记忆功能现在应该能够正常工作。关键是确保：

1. ✅ 前端正确解析 SSE 事件和数据
2. ✅ 前端正确获取和传递 sessionId
3. ✅ 后端使用一致的 sessionId
4. ✅ Memory Advisor 正确配置

如果仍有问题，请查看后端日志和浏览器控制台，根据日志信息进行排查。
